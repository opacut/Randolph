using System;
using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;
using System.Text;
using static System.Environment;

namespace Randolph.Core {
    public class GenerateFiles {

        /// <summary>Generates an enum file from given parameters.</summary>
        /// <param name="enumName">Name of the enum.</param>
        /// <param name="path">Path to the target folder from the project directory, e.g. "Assets/Scripts/Enums" </param>
        /// <param name="enumEntries">All of the enum fields.</param>
        /// <param name="namespace">Optionally, enclose the file in a namespace.</param>
        public static void GenerateEnum(string enumName, string path, string[] enumEntries, string @namespace = "") {
            if (!Validate(ref enumName, ref path)) {
                return;
            }

            string filePath = $"{path}/{enumName}.cs";

            var builder = new StringBuilder();
            string tab = (@namespace == string.Empty) ? "" : "\t"; // extra tab
            builder.Append($"{tab}public enum {enumName} {{\n\n" +
                           $"\t{tab}// Autogenerated\n" +
                           $"\t{tab}{enumEntries.Aggregate((current, next) => $"{current},\n\t{tab}{next}")}\n\n" +
                           $"{tab}}}");

            GenerateFile(filePath, builder.ToString(), @namespace);
        }

        public static void GenerateMonobehaviour(string className, string path, string inheritance = "MonoBehaviour", string @namespace = "", string[] @using = null, string[] fields = null, params string[] methodSignatures) {
            if (!Validate(ref className, ref path)) {
                return;
            }

            string filePath = $"{path}/{className}.cs";

            var builder = new StringBuilder();
            string tab = (@namespace == string.Empty) ? "" : "\t"; // extra tab
            string methods = string.Empty;
            
            if (methodSignatures?.Length > 0) {
                methods = string.Join("", methodSignatures.Select(method => $"\t{tab}{method} {{\n\t\t{tab}throw new NotImplementedException();\n\t{tab}}}\n\n"));
            }
            string allFields = string.Empty;
            if (fields?.Length > 0) {
                allFields = string.Join("", fields.Select(field => $"\t{tab}{field};\n"));
            }

            builder.Append($"{tab}public class {className} : {inheritance} {{\n\n" +
                           $"{allFields}" +
                           $"{methods}" +
                           $"{tab}}}");

            GenerateFile(filePath, builder.ToString(), @namespace, @using);
        }

        static void GenerateFile(string filePath, string contents, string @namespace = "", string[] @using = null) {
            using (var writer = new StreamWriter(filePath)) {
                contents = contents.Replace("\n", $"{NewLine}");

                if (@using?.Length > 0) {
                    string import = string.Join("", @using.Select(use => $"using {use};{NewLine}"));
                    writer.WriteLine(import);
                }


                if (@namespace != string.Empty) writer.WriteLine($"namespace {@namespace} {{");
                writer.WriteLine(contents);
                if (@namespace != string.Empty) writer.WriteLine("}");
            }

            AssetDatabase.Refresh();
        }

        /// <summary>Checks given variable name and a folder path and prepares them to be used.</summary>        
        /// <returns>False if it's pointless to generate such file.</returns>
        static bool Validate(ref string variableName, ref string folderPath) {
            // if (Methods.IsValidVariableName(variableName)) { 
            //! Doesn't work when overwriting
            //     string newName = variableName.ToTitleCase();
            //     Debug.LogError($"<b>{variableName}</b> <i>({newName})</i> isn't a valid variable name.");
            //     return false;
            // }
            if (folderPath.EndsWith("/")) {
                folderPath = folderPath.Remove(folderPath.Length - 1); // Remove last '/'
            }
            if (!AssetDatabase.IsValidFolder(folderPath)) {
                Debug.LogError($"Trying to create a file in folder <b>{folderPath}</b>, which doesn't exist.");
                return false;
            }
            return true;
        }

    }
}
